---
title: "Election 2016"
author: "Melinda"
date: "15 November 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

To install Rmarkdown type the following in R: install.packages("rmarkdown", dep = TRUE)

# Australia's 2016 election

```{r packages}
library(data.table)
library(dplyr)
library(dtplyr)
library(magrittr)
library(tidyr)
```

The function 'fread' comes from the 'data.table' package.  The first argument is either a file (like a 'csv' file) or a URL connection to a file

The function downloads the file (if it's a URL) and then reads it as a table into memory

```{r loadData}
two_party_preferred_by_polling_place <-
  fread("http://results.aec.gov.au/20499/Website/Downloads/HouseTppByPollingPlaceDownload-20499.csv"
)
```

(To run a chunk, type 'Ctrl + C' when your cursor is in the chunk.)

#dplyr

#Basic election results


```{r basis-analysis}
two_party_preferred_by_polling_place %>%
  summarise(avg_swing = mean(Swing))
```

## Exercises:
1. Can you think of a better way to calculate the 'average' swing against the incumbent?

2. Can you think of a better way to calculate the 'average' swing?

3. Which polling place had the biggest swing against the Coalition


We shouldn't weight every polling place equally.  A swing of 15% in a polling place with 33 votes shouldn't swamp swings of 2% in a polling place with 2000 votes.  We use 'weighted.mean' with 'w = TotalVotes' to get around this:

## (2)
```{r average-swing}
two_party_preferred_by_polling_place %>%
  summarise(avg_swing = weighted.mean(Swing, w=TotalVotes))
```

Recall that 'summarise' takes a data frame, and an expression like 'LHS = RHS' where 'LHS' is the column name and 'RHS' is a function of the column names in the data, returning a data frame with a single column, 'LHS' which has the value of the function 'RHS'.

## (3)
```{r biggest-swing-Coalition}
two_party_preferred_by_polling_place %>%
  filter(Swing == max(Swing))
```


## 2013 Election Data
## Exercise:
1. Download the 2013 election polling place data.  Create a new object
'two_party_preferred_by_polling_place_2013' containing the data


```{r two-party-preferred-by-polling-place-2013}
two_party_preferred_by_polling_place_2013 <-
  fread("http://results.aec.gov.au/17496/website/Downloads/HouseTppByPollingPlaceDownload-17496.csv")
```
  2. Determine (without downloading the relevant dataset!) the elected party (ALP or Coalition) of each Division in 2013  
  
  Take the dataset, 'group_by' the Division, then 'summarise' by adding up all the Liberal/Coalition votes (ensuring we use backticks because the variable name contains a slash and spaces) and dividing the sum of total votes.  Then use 'mutate' to add a column, and 'if_else' to conditionally assign the elected party.
  
```{r elected-party-by-Division-2013}
elected_party_by_Division_2013 <-
  two_party_preferred_by_polling_place_2013 %>%
  group_by(DivisionNm)
  summarise(Coalition_2PP = sum(`Liberal/National Coalition Votes`) / sum(TotalVotes)) %>%
  mutate(elected = if_else(Coalition_2PP > 0.5, "Coalition", "ALP"))
```
  

### Homework

## What polling place had the biggest swing against the Coalition?  (Note: not Division, so you may need to amend the previous code...)
## Is an inner join appropriate? Should we use a left/right (outer) join (or a full join) instead?


*** ### all the booths in the Top 10 had 0 votes***

Note: Some electorates were renamed between 2013 and 2016 eg Fraser to Fenner, Throsby to Whitlam.  There are also new electorates in 2016 eg Burt in WA.  Joining on all fields will result in fewer records being matched.  Join amended to link Division ID only for the purposes of pulling in the party of the incumbent Sitting Member.  This leaves only 38 unmatched records that are the polling booths relating to the new electorate of Burt in WA


Let's try to confirm that "Swing" in 'two_party_preferred_by_polling_place' is in fact teh swing against the Coalition.  That is, the percentage of votes to Coalition minus the percentage votes to Coalition in 2013 equals "swing" in 2016. 

```{r polling-place-biggest-swing}
difference_and_swing_by_pollingplaceid <-
two_party_preferred_by_polling_place %>%
  inner_join(two_party_preferred_by_polling_place_2013, by = "PollingPlaceID") %>%
  mutate(ppt_diff_Coalition_votes = `Liberal/National Coalition Percentage.x` - `Liberal/National Coalition Percentage.y`) %>%
  # contains inside select means 'select columns whose names contain that string'
  select(PollingPlaceID, contains("Percentage"), ppt_diff_Coalition_votes, Swing.x) 

```

```{r}
difference_and_swing_by_pollingplaceid %>%
  #select random sample
  sample_n(10)
```

```{r}
difference_and_swing_by_pollingplaceid %$%
# check both columns have the same sign
  # Using {} allows you to use multiple columns after %$%.
  # stopifnot(...) stops (ie errors) if any of the conditions are not met.
  # {stopifnot(all(sign(ppt_diff_Coalition_votes) == sign(Swing.x)))}
 {all(sign(ppt_diff_Coalition_votes) == sign(Swing.x))} ##FALSE

```

Where is the sign not the same?

```{r}
difference_and_swing_by_pollingplaceid %>%
  #subset this table where the signs are different
  filter(sign(ppt_diff_Coalition_votes) !sign(Swing.x)) %>%
  # How many rows?
  nrow
```

What proprotion of the rows have different signs?  We can use `mean` cunningly to test the proportion of `TRUE`s in a column of `TRUE`s and `FALSE`s

```{r}
difference_and_swing_by_pollingplaceid %$%
  #Average rate where signs are not the same.
  mean(sign(ppt_diff_Coalition_votes) !=sign(Swing.x))
```

Conclusion: 'Swing.x' and ppt_diff_Coalition_votes are different.

'select' isn't quite good enough, so let's set an option:
```{r}
options(dplyr.width = Inf)
```


```{r}
difference_and_swing_by_pollingplaceid %>%
  arrange(desc(ppt_diff_Coalition_votes)) %>%
  head(1) %>%
  inner_join(two_party_preferred_by_polling_place, by = "PollingPlaceID")
```

Why can't we use `cbind` as opposed to `inner_join`? Because the PollingPlaceID may not be in the same order: you'll compare different polling places. `cbind` simply smooshes the two tables together.

## Is an inner join appropriate? Should we use a left/right (outer) join (or a full join) instead?

Yes, it's fine! Swings for newly created or no longer existent polling places aren't well-defined. So we can restrict to only those polling places which were present in both elections.

#Is an inner join appropriate?  Should we use a left 