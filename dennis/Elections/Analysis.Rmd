---
title: "Elections"
author: "Dennis"
date: "15/11/2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


# Australia's 2016 election


```{r packages}
library(data.table)
library(dplyr)
library(dtplyr)
library(magrittr)
library(tidyr)

```

The function `fread` comes from the `data.table` package. The 1st argument is either a file
(like a `csv` file) or a URL connection to a file. The function downloads the file (if it's a URL) and then reads it as a table into memory.

To run a chunk, type `Ctrl + C` when your cursor is in the chunk.
``` {r loadData}
two_party_preferred_by_polling_place <-
  fread("http://results.aec.gov.au/20499/Website/Downloads/HouseTppByPollingPlaceDownload-20499.csv")
```

# dplyr

## Basic election results
``` {r basic-analysis}
two_party_preferred_by_polling_place %>%
  summarise(acg_swing = mean(Swing))
```
  
## Exercises:
1. Can you think of a better way to calculate the 'average' swing against the incumbent?
``` {r average-swing}
two_party_preferred_by_polling_place %>%
  summarise(avg_swing = weighted.mean(Swing, w = TotalVotes))
```

2. Can you think of a better way to calculate the 'average' swing?
We shouldn't weight every polling place equally. A swing of 15% in a polling place with 33 votes shouldn't swamp swings of 2% in a polling place with 2000 votes. We use `weighted.mean` with `w = TotalVotes` to get around this:
``` {r average-swing-2}
two_party_preferred_by_polling_place %>%
  summarise(avg_swing = weighted.mean(Swing, w = TotalVotes))
```
Recall that `summarise` takes a data frame, and an expression like `LHS = RHS` where `LHS` is the column name and `RHS` is a function of the column names in the data, returning a data frame with a single column, `LHS` which has the value of the function `RHS`.


3. Which polling place had the biggest swing against the Coalition?
``` {r biggest-swing-Coalition}
two_party_preferred_by_polling_place %>%
  filter(Swing == max(Swing))
```
With the current dataset it is not possible to answer this question.


## 2013 election
### Exercise:
1. Download the 2013 election polling place data. Create a new object `two_party_preferred_by_polling_2013` containing the data.

``` {r 2013-loadData}
two_party_preferred_by_polling_place_2013 <-
  fread("http://results.aec.gov.au/17496/Website/Downloads/HouseTppByPollingPlaceDownload-17496.csv")
```

2. Determine (without downloading the relevant dataset!) the elected party (ALP or Coalition) of each Division in 2013.
Take the dataset, `group_by`, then `ummarise` by adding up all the Liberal/Coalition votes (ensuring we use backticks because the column name contains a slash and spaces) and dividing by the sum of the total votes. Then use `mutate` to add a column, and `if_else` to conditionally assign the elected party.
``` {r elected-party-by-Division-2013}
elected_party_by_Division_2013 <-
  two_party_preferred_by_polling_place_2013 %>%
  group_by(DivisionNm) %>%
  summarise(Coalition_2PP = sum(`Liberal/National Coalition Votes`) / sum(TotalVotes)) %>% # returns the average % for Coalition per division
  mutate(elected = if_else(Coalition_2PP > 0.5, "Coalition", "ALP")) # If > 0.5 means Coalition had more than 50% of the votes and won this division; the if_else here just makes the output nicer
```

``` {r}
two_party_preferred_by_polling_place %>%
  # joins on all common names
  inner_join(elected_party_by_Division_2013) # right_join or left_join for an outer join
```

### Homework
## What polling place had the biggest swing against the Coalition (note: not Division, so you need to amend the previous code...)? (see above - couldn't answer)
`select` isn't quite good enough, so let's set an option:
``` {r}
options(dplyr.width = Inf)
```

Let'stry to confirm that `Swing` in `two_party_preferred_by_polling_place` is in fact
the swing against the Coalition. That is the percentage of votes to Coalition minus the percentage votes to Coalition in 2013 equals `Swing` in 2016
``` {r polling-place-biggest-swing}
difference_and_swing_by_pollingplaceid <-
two_party_preferred_by_polling_place %>%
  inner_join(two_party_preferred_by_polling_place_2013, by = "PollingPlaceID") %>%
  tbl_df %>% # for prettier printing
  mutate(ppt_diff_Coalition_votes = `Liberal/National Coalition Percentage.x` - `Liberal/National Coalition Percentage.y`) %>%
  # contains inside select means 'select columns whose names contains that string'
  select(PollingPlaceID, contains("Percentage"), ppt_diff_Coalition_votes, Swing.x)
```

``` {r}
difference_and_swing_by_pollingplaceid %>%
# selec random sample, e.g. 10 rows from the dataset
  sample_n(10)
```

``` {r}
difference_and_swing_by_pollingplaceid %$%
  {all(sign(ppt_diff_Coalition_votes) == sign(Swing.x))} ## FALSE
  # check both columns have the same sign.
  # Using {} allows you to use multiple columns after %$%.
  # stopifnot(...) stops (i.e. errros) if any of the conditions are not met.
  # {stopifnot(all(sign(ppt_diff_Coalition_votes) == sign(Swing.x)))}
```

Where is the sign not the same?
``` {r}
difference_and_swing_by_pollingplaceid %>%
  # subset this table where the signs are different
  filter(sign(ppt_diff_Coalition_votes) != sign(Swing.x)) %>%
  # How many rows?
  nrow
```

What proportion of the rows have different signs?
``` {r}
difference_and_swing_by_pollingplaceid %$%
  # average rate where signs are not the same.
  mean(sign(ppt_diff_Coalition_votes) != sign(Swing.x))
``` 

Conclusion: `Swing.x` and `ppt_diff_Coalition_votes` are different.
``` {r}
difference_and_swing_by_pollingplaceid %>%
  arrange(desc(ppt_diff_Coalition_votes)) %>%
  head(1) %>%
  inner_join(two_party_preferred_by_polling_place, by = "PollingPlaceID")
```

Why can't we use `cbind`?
Because the PollingPlaceID may not be in the same order. cbind just joins each row one by one and not by a specified ID. So, there could be rows of different `PollingPlaceID`'s bound.


## Is an inner join appropriate? Should we use a left/right (outer)/full join instead?
Yes it's fine! Swings for newly created or not longer existent polling places aren't well-defined. So we can rstrict to only those polling places which were present in both elections.


